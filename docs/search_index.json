[["index.html", "ReadingNotes: Have you read todays papers? Preface", " ReadingNotes: Have you read todays papers? Rongting Huang rthuang@connect.hku.hk 2021-09-14 Preface This book is for Rongtings daily reading notes. "],["about-the-author.html", "About the author", " About the author Keep moving Note: to build this book, use the following script in R and follow the bookdown mannual: bookdown::render_book(&quot;index.Rmd&quot;, &quot;bookdown::gitbook&quot;) "],["intro.html", "Chapter 1 Introduction", " Chapter 1 Introduction You can label chapter and section titles using {#label} after them, e.g., we can reference Chapter 1. If you do not manually label them, there will be automatic labels anyway, e.g., Chapter 6.4.1.2. Figures and tables with captions will be placed in figure and table environments, respectively. par(mar = c(4, 4, .1, .1)) plot(pressure, type = &#39;b&#39;, pch = 19) Figure 1.1: Here is a nice figure! Reference a figure by its code chunk label with the fig: prefix, e.g., see Figure 1.1. Similarly, you can reference tables generated from knitr::kable(), e.g., see Table 1.1. knitr::kable( head(iris, 20), caption = &#39;Here is a nice table!&#39;, booktabs = TRUE ) Table 1.1: Here is a nice table! Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 4.6 3.4 1.4 0.3 setosa 5.0 3.4 1.5 0.2 setosa 4.4 2.9 1.4 0.2 setosa 4.9 3.1 1.5 0.1 setosa 5.4 3.7 1.5 0.2 setosa 4.8 3.4 1.6 0.2 setosa 4.8 3.0 1.4 0.1 setosa 4.3 3.0 1.1 0.1 setosa 5.8 4.0 1.2 0.2 setosa 5.7 4.4 1.5 0.4 setosa 5.4 3.9 1.3 0.4 setosa 5.1 3.5 1.4 0.3 setosa 5.7 3.8 1.7 0.3 setosa 5.1 3.8 1.5 0.3 setosa You can write citations, too. For example, we are using the bookdown package (Xie 2021) in this sample book, which was built on top of R Markdown and knitr (Xie 2015). References "],["sgcell.html", "Chapter 2 SingleCell 2.1 Technology 2.2 Review 2.3 Data processing 2.4 Clustering methods 2.5 languages and compilers 2.6 singlecell analysis tools 2.7 singlecell analysis sources", " Chapter 2 SingleCell 2.1 Technology 2.1.1 single cell scDNA scRNA scATAC 2.1.2 spatial single cell 2.2 Review 2.2.1 Review-2021-06 The triumphs and limitations of computational methods for scRNA-seq(Kharchenko 2021) Though computational approaches vary, most formulate (1) a statistical model of the measurement, (2) a representation of the data in reduced dimensions, and (3) an approximation of the expression manifold (Box 2), with a set of discrete transcriptional subpopulations being the simplest and the most common approximation. The problems motivating these steps, and the specific solutions and their assumptions, are the subject of this review. Key preprocessing steps in single-cell RNA-seq analysis Key analysis steps in single-cell RNA-seq analysis Key analysis steps in single-cell RNA-seq analysis Box 1 Select software tools Tools for alignment, barcode correction, count matrix estimation, and quality control include: CellRanger (https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/installation): supports 10x Chromium datasets (commercial product) dropEst (https://github.com/hms-dbmi/dropEst): supports multiple droplet-based protocols STAR (https://github.com/alexdobin/STAR): aligner (used internally by CellRanger and dropEst), also has built-in options for count matrix estimation Optimus (https://data.humancellatlas.org/pipelines/optimus-workflow): supports 10x Chromium v2 and v3 datasets, designed for Human Cell Atlas Kallisto/bustools (https://www.kallistobus.tools): fast processing using pseudoalignment Cell filter and doublet identification tools include: EmptyDrops (https://rdrr.io/github/MarioniLab/DropletUtils/man/emptyDrops.html): uses a classifier to distinguish empty cells that look like the low-end tail of the cell size distribution Scrublet (https://github.com/AllonKleinLab/scrublet): python-based, doublet simulation and doublet scoring doubletFinder (https://github.com/chris-mcginnis-ucsf/DoubletFinder): R-based, doublet simulation and doublet scoring scds (https://github.com/kostkalab/scds): fast doublet scoring implementation Tools for normalization, dimensionality reduction, and clustering and differential expression include: Seurat (https://satijalab.org/seurat/): the most popular analysis toolkit, R-based scanpy (https://github.com/theislab/scanpy): the most popular python-based toolkit scVI (https://github.com/YosefLab/scVI): latent space identification using variational neural net pagoda2 (https://github.com/hms-dbmi/pagoda2): fast, R-based processing SAUCIE (https://www.krishnaswamylab.org/projects/saucie): a neural-net-based dimensionality reduction, using maximal mean discrepancy penalty Tools for trajectory fitting include: Monocle3 (https://cole-trapnell-lab.github.io/monocle3/): third iteration of the Monocle package, including updated tree utilities Slingshot (https://github.com/kstreet13/slingshot): tree fitting with improved pseudotime estimation PAGA (https://github.com/theislab/paga): tree/graph fitting approach combined with cell aggregation, also supports cluster-based velocity estimates Wishbone (https://dpeerlab.github.io/dpeerlab-website/wishbone.html): a bifurcation analysis method Destiny, DPT (https://github.com/theislab/destiny/): dimensionality reduction and trajectory fitting using diffusion maps82 Tools for velocity estimation include: velocyto (http://velocyto.org/): reference python/R implementation scVelo (https://scvelo.readthedocs.io/): new implementation using curve-based phase portrait fit 2.2.1.1 Statistical view of a cell 2.2.1.2 Comparing transcriptional states 2.2.1.3 The quest for reduced dimensions 2.2.1.4 scRNA-seq basics scRNA-seq basics a, Beating Moores law. The number of cells measured by landmark scRNA-seq datasets over years (red), compared with the increase in the CPU transistor counts (black). The set of all published scRNA-seq studies83 is shown with small red dots. The estimated number of cells in a human body is shown by a green dashed line. b, Shallow coverage of each cell can be compensated for by measuring more cells. The ability to distinguish two cell populations, assessed by the area under the receiver operating characteristic curve (ROC AUC) measure, is shown as a function of the number of measured cells (x axis) and the mean cell depth (y axis). Examples of three different simulations (1-3) within different parts of this design parameter space are shown on PCA projections. c, Probabilistic view of scRNA-seq estimates. Posterior probability of IL32 gene expression magnitude is shown for five cells from two different CD8+ T cell populations (red and blue, thin lines). Joint posteriors assessing the mean expression magnitude within each subpopulation are shown by thick dashed lines. d, Comparing CD4+ T cells and CD14+ monocytes, the plot shows the number (y axis, left) and the fraction (y axis, right) of the genes passing a 1% statistical significance threshold for differential expression (DE) as a function of the number of cells compared from each population (x axis). e, The scatter plot shows for each gene (dots) the mean (x axis) and variance (y axis) of the normalized UMI counts (CPM, counts per million) in CD4+ T cells. The Poisson expected value is shown in green, with a quadratic-based negative binomial fit shown in red. f-i, Variance normalization and most variable genes. f, A t-SNE embedding of a primary peripheral blood mononuclear cell (PBMC) dataset with cell annotations. NK, natural killer, separated into CD56 bright and dim subsets. pDC, plasmacytoid dendritic cell. g, Mean-variance relationship of different genes (dots) in the PBMC dataset is shown for log-transformed expression estimates. The genome-wide relationship, as captured by smoothed regression, is shown by the blue line. Genes whose variance is significantly higher than the genome-wide trend are shown as red dots. h, Residual variance is shown for the top 5,000 overdispersed genes, ordered by the statistical significance (x axis). i, Expression pattern of several example genes, with circles highlighting the subpopulations distinguished by the genes. j, Distribution of normalized expression magnitudes (CPM) for the CTSH gene across all CD14+ monocytes is shown on the linear scale (top) and after log transformation (bottom) with a pseudocount. 2.2.2 Review-2021-07 Computational principles and challenges in single-cell data integration(Argelaguet et al. 2021) 2.3 Data processing Bayesian inference of gene expression states from single-cell RNA-seq data(Breda, Zavolan, and Nimwegen 2021) summary of sanity approach summary of sanity approach sanity notes 2.4 Clustering methods 2.5 languages and compilers Seq A Python-based programming language for high-performance computational genomics(Shajii et al. 2021) The Seq programming language. a, Conceptual comparison of Seq, Python and C++. Seq combines the high performance of C++ with the programming ease and clarity of Python, by virtue of domain-specific compiler optimizations that are hidden from the user. b, Example Seq code for a simple k-mer-based read mapper. c, Schematic of standard genomics pipeline and those state-of-the-art tools compared to Seq. To demonstrate Seqs versatility, we reimplemented eight popular genomics tools in Seq, spanning key tasks in the genomics analysis pipeline (Fig. 1c and Supplementary Note 2), such as the finding of super-maximal exact matches, or SMEMs (BWA-MEM13), genome homology table construction (CORA14), Hamming distance-based all-mapping (mrsFAST15), long-read alignment (minimap216), single-cell data preprocessing (UMI-tools17), SAM/BAM post-processing (GATK18), global sequence alignment (AVID19) and haplotype phasing (Haptree-X20,21). Hap Tree-X 2.6 singlecell analysis tools scanpy SCANPY: large-scale single-cell gene expression data analysis seurat 2.7 singlecell analysis sources References "],["technology-related.html", "Chapter 3 Technology Related 3.1 scRNA-seq 3.2 Hi-Seq", " Chapter 3 Technology Related 3.1 scRNA-seq 3.1.1 NB models for scRNA-seq DEseq2, scTransform, BASICS DEseq2 Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2(Love, Huber, and Anders 2014) DEseq2 DEseq2-fig1 Shrinkage estimation of dispersion. Plot of dispersion estimates over the average expression strength (A) for the Bottomly et al. [16] dataset with six samples across two groups and (B) for five samples from the Pickrell et al. [17] dataset, fitting only an intercept term. First, gene-wise MLEs are obtained using only the respective genes data (black dots). Then, a curve (red) is fit to the MLEs to capture the overall trend of dispersion-mean dependence. This fit is used as a prior mean for a second estimation round, which results in the final MAP estimates of dispersion (arrow heads). This can be understood as a shrinkage (along the blue arrows) of the noisy gene-wise estimates toward the consensus represented by the red line. The black points circled in blue are detected as dispersion outliers and not shrunk toward the prior (shrinkage would follow the dotted line). For clarity, only a subset of genes is shown, which is enriched for dispersion outliers. Additional file 1: Figure S1 displays the same data but with dispersions of all genes shown. MAP, maximum a posteriori; MLE, maximum-likelihood estimate. scTransform Normalization and variance stabilization of single-cell RNA-seq data using regularized negative binomial regression(Hafemeister and Satija 2019) https://github.com/ChristophH/sctransform/ SCTransform We propose that the Pearson residuals from regularized negative binomial regression, where cellular sequencing depth is utilized as a covariate in a generalized linear model, successfully remove the influence of technical characteristics from downstream analyses while preserving biological heterogeneity. UMI-based scRNA-seq dataset BASiCS BASiCS: Bayesian Analysis of Single-Cell Sequencing Data(Vallejos, Marioni, and Richardson 2015) KEY WORDS: scRNA-seq counts 3.2 Hi-Seq Enhanced detection of minimal residual disease by targeted sequencing of phased variants in circulating tumor DNA(Kurtz et al. 2021) KEY WORDS: phased variants References "],["statmethods.html", "Chapter 4 StatMethods 4.1 HMM based methods 4.2 EM based methods 4.3 VB based methods", " Chapter 4 StatMethods 4.1 HMM based methods 4.2 EM based methods 4.3 VB based methods "],["research-topic-based.html", "Chapter 5 Research topic based 5.1 CNV calling 5.2 Clonal Tree 5.3 Deconvolution 5.4 Omics integration", " Chapter 5 Research topic based 5.1 CNV calling 5.1.1 breaking point detection 4 CNV breakpoint detection methods (2021-07-17 Group meeting) CHISEL: https://www.nature.com/articles/s41587-020-0661-6#Sec8 (see global clustering subsection) seemingly no breakpoint detection, but rather a global clustering (ie. entry-wise for a bin-by-cell matrix), thus the resolution of CNV is the bin size (5MB) Alleloscope: https://www.nature.com/articles/s41587-021-00911-w#Sec10 (see segmentation subsection) HMM on a pooled cells (pseudo-bulk?) with pre-defined Gaussian means and variance for each state InferCNV: https://github.com/broadinstitute/inferCNV/wiki/inferCNV-HMM-based-CNV-Prediction-Methods i6-HMM generates in silico spike-in; seemingly define CNV region (segment) on cluster instead of cell, but using noise model on each cell (not quite sure from the doc). CopyKat: https://www.nature.com/articles/s41587-020-00795-2#Sec9 KS test for whether to two neighbour bins should be joined, by using the posterior samples of Gamma-Poisson posterior. Seemingly using noise model on each cell within a cluster FACLON https://academic.oup.com/nar/article/43/4/e23/2410993 Overview of HATCHet algorithm https://www.nature.com/articles/s41467-020-17967-y/figures/1 a HATCHet takes in input DNA sequencing data from multiple bulk tumor samples of the same patient and has five steps. b First, HATCHet calculates the RDRs and BAFs in bins of the reference genome (black squares). Here, we show two tumor samples p and q. c Second, HATCHet clusters the bins based on RDRs and BAFs globally along the entire genome and jointly across samples p and q. Each cluster (color) includes bins with the same copy-number state within each clone present in p or q. d Third, HATCHet estimates two values for the fractional copy number of each cluster by scaling RDRs. If there is no WGD, the identification of the cluster (magenta) with copy-number state (1, 1) is sufficient and RDRs are scaled correspondingly. If a WGD occurs, HATCHet identifies an additional cluster with identical copy-number state in all tumor clones. Dashed black horizontal lines in the scaled BAF-RDR plot represent values of fractional copy numbers that correspond to clonal CNAs. e Fourth, HATCHet factors the allele-specific fractional copy numbers FA, FB into the allele-specific copy numbers A, B, respectively, and the clone proportions U. Here, there is a normal clone and 3 tumor clones. f Last, HATCHets model-selection criterion identifies the matrices A, B, and U in the factorization while evaluating the fit according to both the inferred number of clones and presence/absence of a WGD. g HATCHet outputs allele- and clone-specific copy numbers (with the color of the corresponding clone) and clone proportions (in the top right part of each plot) for each sample. Clusters are classified according to the inference of unique/different copy-number states in each sample (sample-clonal/subclonal) and across all tumor clones (tumor-clonal/subclonal). Overview of chisel algorithm https://www.nature.com/articles/s41587-020-0661-6/figures/1 a, CHISEL computes RDRs and BAFs in low-coverage (&lt;0.05× per cell) single-cell DNA sequencing data (top left). Read counts from 2,000 individual cells (rows) in 5-Mb genomic bins (columns) across three chromosomes (gray rectangles in first row) are shown. For each bin in each cell, CHISEL computes the RDR (top) by normalizing the observed read counts. CHISEL computes the BAF in each bin and cell (bottom) by first performing referenced-based phasing of germline SNPs in 50-kb haplotype blocks (magenta and green) and then phasing all these blocks jointly across all cells. b, CHISEL clusters RDRs and BAFs globally along the genome and jointly across all cells resulting here in five clusters of genomic bins (red, blue, purple, yellow and gray) with distinct copy-number states. c, CHISEL infers a pair {c^t,ct} of allele-specific copy numbers for each cluster by determining whether the allele-specific copy numbers of the largest balanced (BAF of ~0.5) cluster are equal to {1, 1} (diploid), {2, 2} (tetraploid) or are higher ploidy. d, CHISEL infers haplotype-specific copy numbers (at, bt) by phasing the allele-specific copy numbers {c^t,ct} consistently across all cells. e, CHISEL clusters tumor cells into clones according to their haplotype-specific copy numbers. Here, a diploid clone (light gray) and two tumor clones (red and blue) are obtained. A phylogenetic tree describes the evolution of these clones. Somatic SNVs are derived from pseudo-bulk samples and placed on the branches of the tree. Overview of TITAN local clustering for segemetation Overview of inferCNV i3HMM Overview of inferCNV i6HMM Overview of HoneyBADGER method Overview of Alleloscope algorithm Overview of copykat algorithm 5.2 Clonal Tree 5.3 Deconvolution 5.3.1 Deconvolution of bulk tissue and spatial transcriptomic data Related papers are as follows: CIBERSORTx RCTD SPOTlight SpatialDWLS From xiunans pre Reference-free cell-type deconvolution of pixel-resolution spatially resolved transcriptomics data Yuanhua add 5.4 Omics integration "],["proteomics.html", "Chapter 6 Proteomics 6.1 PTM cross-talk 6.2 PTM Cluster 6.3 6.4 Protein structure", " Chapter 6 Proteomics 6.1 PTM cross-talk 6.2 PTM Cluster 6.3 6.4 Protein structure 6.4.1 Protein Folding Prediction Background 6.4.1.1 introduction How to record a protein structue What to predict 6.4.1.2 methods ReceptorX ReceptorX-d trRosetta AlphaFold1 AlphaFold2 6.4.1.3 deep learing in protein structure prediction "],["references.html", "References", " References "]]
